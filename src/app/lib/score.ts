import { TileType } from "./app-context";

// This for testing
export const grid = [
  [2, 1, 1, 1, 1, 1, 2, 1],
  [1, 2, 2, 1, 2, 2, 1, 1],
  [1, 1, 2, 1, 2, 1, 1, 1],
  [1, 1, 2, 2, 1, 1, 1, 1],
  [1, 1, 2, 1, 2, 1, 1, 1],
  [1, 2, 2, 1, 2, 2, 1, 1],
  [2, 1, 2, 1, 2, 1, 2, 1],
  [2, 2, 2, 2, 1, 1, 1, 2],
]

// This function generated by Claude AI
// keyword
// const grid = [
//   [2, 1, 1, 1, 1, 1, 2, 1],
//   [1, 2, 2, 1, 2, 2, 1, 1],
//   [1, 1, 2, 1, 2, 1, 1, 1],
//   [1, 1, 2, 2, 1, 1, 1, 1],
//   [1, 1, 2, 1, 2, 1, 1, 1],
//   [1, 2, 2, 1, 2, 2, 1, 1],
//   [2, 1, 2, 1, 2, 1, 2, 1],
//   [2, 2, 2, 2, 1, 1, 1, 2],
// ]
// create a function to find at least  4 consecutive data in given array in every row, every column and every diagonal in typescript
// group the consecutive result in array of position in given array
// remove at least 4 intersection position from result
// 
// const expectedResult = [
//   [[0, 1], [0, 2], [0, 3], [0, 4]], // 1 blue horizontal
//   [[3, 4], [3, 5], [3, 6], [3, 7]], // 1 blue horizontal
//   [[7, 0], [7, 1], [7, 2], [7, 3]], // 2 red horizontal
//   [[1, 0], [2, 0], [3, 0], [4, 0], [5, 0]], // 2 red vertical
//   [[1, 2], [2, 2], [3, 2], [4, 2], [5, 2], [6, 2], [7, 2]], // 2 red vertical
//   [[1, 6], [2, 6], [3, 6], [4, 6], [5, 6]], // 1 blue vertical
//   [[0, 7], [1, 7], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7]], // 1 blue vertical
//   [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]], // 2 red diagonal right
//   [[0, 6], [1, 5], [2, 4], [3, 3], [4, 2], [5, 1], [6, 0]], // 2 red diagonal left
//   [[0, 7], [1, 6], [2, 5], [3, 4], [4, 3]], // 1 blue diagonal left
//   [[2, 3], [3, 4], [4, 5], [5, 6], [6, 7]], // 1 blue diagonal right ***
//   [[4, 7], [5, 6], [6, 5], [7, 4]] // 1 blue diagonal left
// ]

type Grid = number[][];

interface Position {
  row: number;
  col: number;
}

interface Sequence {
  value: number;
  positions: Position[];
  coordinates: string[];
  direction: string;
  length: number;
}

export function findConsecutiveSequences(grid: Grid): { found: boolean; sequences: Sequence[] } {
  const rows = grid.length;
  const cols = grid[0].length;
  const sequences: Sequence[] = [];
  const usedPositions = new Set<string>();

  // Helper to convert position to string key for comparison
  function positionToKey(pos: Position): string {
    return `${pos.row},${pos.col}`;
  }

  // Check if sequence has too many intersections with existing sequences
  function hasTooManyIntersections(positions: Position[]): boolean {
    let intersectionCount = 0;
    for (const pos of positions) {
      const key = positionToKey(pos);
      if (usedPositions.has(key)) {
        intersectionCount++;
        if (intersectionCount > 3) {
          return true;
        }
      }
    }
    return false;
  }

  // Add positions to used positions set
  function markPositionsAsUsed(positions: Position[]) {
    positions.forEach(pos => {
      usedPositions.add(positionToKey(pos));
    });
  }

  // Check if a sequence is valid and add it to results
  function checkAndAddSequence(
    sequence: number[],
    startRow: number,
    startCol: number,
    direction: string,
    getPosition: (index: number) => Position
  ) {
    let currentNum = sequence[0];
    let count = 1;
    let currentPositions: Position[] = [getPosition(0)];
    let maxCount = 1;
    let maxSequence: Position[] = [];
    let maxValue = currentNum;

    for (let i = 1; i < sequence.length; i++) {
      if (sequence[i] === currentNum) {
        count++;
        currentPositions.push(getPosition(i));
        if (count > maxCount) {
          maxCount = count;
          maxSequence = [...currentPositions];
          maxValue = currentNum;
        }
      } else {
        currentNum = sequence[i];
        count = 1;
        currentPositions = [getPosition(i)];
      }
    }

    if (maxCount >= 4) {
      if (!hasTooManyIntersections(maxSequence) && maxValue > 0) {
        sequences.push({
          value: maxValue,
          positions: maxSequence,
          coordinates: maxSequence.map(el => positionToKey(el)),
          direction,
          length: maxCount
        });
        markPositionsAsUsed(maxSequence);
        return true;
      }
    }
    return false;
  }

  let found = false;

  // Check horizontally
  for (let i = 0; i < rows; i++) {
    if (checkAndAddSequence(
      grid[i],
      i,
      0,
      'horizontal',
      (index) => ({ row: i, col: index })
    )) {
      found = true;
    }
  }

  // Check vertically
  for (let j = 0; j < cols; j++) {
    const column = grid.map(row => row[j]);
    if (checkAndAddSequence(
      column,
      0,
      j,
      'vertical',
      (index) => ({ row: index, col: j })
    )) {
      found = true;
    }
  }

  // Check diagonals (top-left to bottom-right)
  for (let k = 0; k <= rows - 4; k++) {
    for (let l = 0; l <= cols - 4; l++) {
      const diagonal: number[] = [];
      let i = k;
      let j = l;
      while (i < rows && j < cols) {
        diagonal.push(grid[i][j]);
        i++;
        j++;
      }
      if (diagonal.length >= 4) {
        if (checkAndAddSequence(
          diagonal,
          k,
          l,
          'diagonal-right',
          (index) => ({ row: k + index, col: l + index })
        )) {
          found = true;
        }
      }
    }
  }

  // Check anti-diagonals (top-right to bottom-left)
  for (let k = 0; k <= rows - 4; k++) {
    for (let l = cols - 1; l >= 3; l--) {
      const diagonal: number[] = [];
      let i = k;
      let j = l;
      while (i < rows && j >= 0) {
        diagonal.push(grid[i][j]);
        i++;
        j--;
      }
      if (diagonal.length >= 4) {
        if (checkAndAddSequence(
          diagonal,
          k,
          l,
          'diagonal-left',
          (index) => ({ row: k + index, col: l - index })
        )) {
          found = true;
        }
      }
    }
  }

  return { found, sequences };
}

// Example usage:
// const result = findConsecutiveSequences(grid);
// if (result.found) {
//     console.log("Found sequences (with intersections removed):");
//     result.sequences.forEach(sequence => {
//         console.log(`\nValue: ${sequence.value}`);
//         console.log(`Direction: ${sequence.direction}`);
//         console.log(`Length: ${sequence.length}`);
//         console.log("Positions:", sequence.positions);
//     });
// } else {
//     console.log("No sequences of 4 or more consecutive numbers found.");
// }

export function fetchAllConnected(sequences: Sequence[]) {
  return sequences.map(sequence => sequence.coordinates.map)
}

export function isInConnected(position: number[], allConnected: number[]): boolean {
return false

}
